## /*
#	@description
#
#	description@
#
#	@notes
#	-
#	notes@
#
#	@examples
#	The example(s) below assume the file you are editing is cfg/user.overrides
#	1) export keep_git_motd="true"
#		- motd will not be replaced
#	2) export keep_git_motd="yes please"
#		- motd will not be replaced
#	3) export keep_default_prompt=""
#		- prompt will be replaced by GitScripts prompt!
#	examples@
#
#	@dependencies
#	gitscripts/path/to/file
#	dependencies@
## */


# set this flag to replace to keep the original Git motd
if [ -z "${keep_git_motd}" ]; then
	cp "${gitscripts_motd_path}" "${native_motd_path}"
fi



# set this flag to keep your own command prompt (PS1) definition
if [ -z "${keep_default_prompt}" ]; then


	GIT_PS1_SHOWDIRTYSTATE=true
	GIT_PS1_SHOWUNTRACKEDFILES=true


	# origin of work http://henrik.nyh.se/2008/12/git-dirty-prompt
	# These are the character codes I used for the git dirty state in the project.
	# ‘☭’ – files have been modified
	# ‘?’ – there are untracted files in the project
	# ‘*’ – a new file has been add to the project but not committed
	# ‘+’ – the local project is ahead of the remote
	# ‘>’ – file has been moved or renamed

	function parse_git_dirty {
	  status=`git status 2> /dev/null`
	  staged=` echo -n "${status}" 2> /dev/null | grep -q "Changes to be committed" 2> /dev/null; echo "$?"`
	  dirty=`    echo -n "${status}" 2> /dev/null | grep -q "Changed but not updated" 2> /dev/null; echo "$?"`
	  untracked=`echo -n "${status}" 2> /dev/null | grep -q "Untracked files" 2> /dev/null; echo "$?"`
	  ahead=`    echo -n "${status}" 2> /dev/null | grep -q "Your branch is ahead of" 2> /dev/null; echo "$?"`
	  newfile=`  echo -n "${status}" 2> /dev/null | grep -q "new file:" 2> /dev/null; echo "$?"`
	  renamed=`  echo -n "${status}" 2> /dev/null | grep -q "renamed:" 2> /dev/null; echo "$?"`
	  modified=`  echo -n "${status}" 2> /dev/null | grep -q "modified:" 2> /dev/null; echo "$?"`
	  bits=''

	  if [ "${dirty}" == "0" ]; then
	    bits="${bits} ${X}${STYLE_DIRTY} + (dirty) ${X}"
	  fi
	  if [ "${modified}" == "0" -a "${staged}" == "0" -a "${dirty}" == "1" ]; then
	    bits="${bits} ${X}${STYLE_COMMITTED} ++ (staged) ${X}"
	  fi

	  if [ "${modified}" == "0" -a "${staged}" == "0" -a "${dirty}" == "0" ]; then
	    bits="${bits} ${X}${STYLE_MODIFIED} >> (modified) ${X}"
	  fi


	  echo ""
	  echo "Staged: ${staged}"
	  echo "Dirty: ${dirty}"
	  echo "Modified: ${modified}"


	  if [ "${modified}" == "0" -a "${staged}" == "1" ]; then
	    bits="${bits} ${X}${STYLE_MODIFIED} >> (modified) ${X}"
	  fi
	  if [ "${untracked}" == "0" ]; then
	    bits="${bits} ${X}${STYLE_UNTRACKED} ? (untracked) ${X}"
	  fi
	  if [ "${newfile}" == "0" ]; then
	    bits="${bits} ${X}${STYLE_NEWFILE} * (newfile) ${X}"
	  fi
	  if [ "${ahead}" == "0" ]; then
	    bits="${bits} ${X}${STYLE_AHEAD} + (ahead) ${X}"
	  fi
	  if [ "${renamed}" == "0" ]; then
	    bits="${bits} > (renamed) "
	  fi
	  echo "${bits}"
	}

	function __parse_git_branch_state {
	#  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/(\1$(parse_git_dirty))/"
	  echo "$(parse_git_dirty)"
	}

	PS1='
${STYLE_PROMPT_USER}\u@\h${X} ${STYLE_PROMPT_DATE}\d \t${X} ${STYLE_PROMPT_PATH}\w${COL_NORM}
${STYLE_PROMPT_BRANCH} $(__parse_git_branch) ${X}$(__parse_git_branch_state)${X}
$ '
fi



# set this flag to exclude bashmarks functionality.
if [ -z "${exclude_bashmarks}" ]; then
	source "${gitscripts_path}bashmarks.sh"
fi

# set this flag to exclude GitScripts basic Git command aliases. see file for definitions.
if [ -z "${exclude_git_aliases}" ]; then
	source "${gitscripts_path}git_aliases.sh"
fi

# set this flag to
#if [ -z "${}" ]; then

#fi